diff --git a/config/gcc-plugin.m4 b/config/gcc-plugin.m4
index 8f278719118..6f01769f001 100644
--- a/config/gcc-plugin.m4
+++ b/config/gcc-plugin.m4
@@ -21,6 +21,9 @@ AC_DEFUN([GCC_ENABLE_PLUGINS],
    pluginlibs=
    plugin_check=yes
 
+   PICFLAG="-fPIC"
+   UNDEFINEDPREAMBLE="extern int X;"
+   UNDEFINEDCODE="return X == 0;"
    case "${host}" in
      *-*-mingw*)
        # Since plugin support under MinGW is not as straightforward as on
@@ -43,6 +46,11 @@ AC_DEFUN([GCC_ENABLE_PLUGINS],
 	 export_sym_check=
        fi
      ;;
+     *-*-mingw*|*-*-cygwin*|*-*-msys*)
+       PICFLAG=""
+       UNDEFINEDPREAMBLE=""
+       UNDEFINEDCODE=""
+     ;;
      *)
        if test x$build = x$host; then
 	 export_sym_check="objdump${exeext} -T"
@@ -94,17 +102,17 @@ AC_DEFUN([GCC_ENABLE_PLUGINS],
      case "${host}" in
        *-*-darwin*)
 	 CFLAGS=`echo $CFLAGS | sed s/-mdynamic-no-pic//g`
-	 CFLAGS="$CFLAGS -fPIC"
+	 CFLAGS="$CFLAGS ${PICFLAG}"
 	 LDFLAGS="$LDFLAGS -shared -undefined dynamic_lookup"
        ;;
        *)
-	 CFLAGS="$CFLAGS -fPIC"
-	 LDFLAGS="$LDFLAGS -fPIC -shared"
+	 CFLAGS="$CFLAGS ${PICFLAG}"
+	 LDFLAGS="$LDFLAGS ${PICFLAG} -shared"
        ;;
      esac
-     AC_MSG_CHECKING([for -fPIC -shared])
+     AC_MSG_CHECKING([for ${PICFLAG} -shared])
      AC_TRY_LINK(
-       [extern int X;],[return X == 0;],
+       [${UNDEFINEDPREAMBLE}],[${UNDEFINEDCODE}],
        [AC_MSG_RESULT([yes]); have_pic_shared=yes],
        [AC_MSG_RESULT([no]); have_pic_shared=no])
      if test x"$have_pic_shared" != x"yes" -o x"$ac_cv_search_dlopen" = x"no"; then
diff --git a/gcc/config.in b/gcc/config.in
index 5bccb408016..9fc2c76b65a 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -2219,6 +2219,12 @@
 #endif
 
 
+/* Define if your system supports PT_GNU_EH_FRAME for static executable. */
+#ifndef USED_FOR_TARGET
+#undef USE_EH_FRAME_HDR_FOR_STATIC
+#endif
+
+
 /* Define to 1 if the 'long long' type is wider than 'long' but still
    efficiently supported by the host hardware. */
 #ifndef USED_FOR_TARGET
diff --git a/gcc/config/xtensa/elf.h b/gcc/config/xtensa/elf.h
index a95d7b34229..4148cc504ee 100644
--- a/gcc/config/xtensa/elf.h
+++ b/gcc/config/xtensa/elf.h
@@ -53,11 +53,11 @@ along with GCC; see the file COPYING3.  If not see
   %{mno-auto-litpools:--no-auto-litpools}"
 
 #undef LIB_SPEC
-#define LIB_SPEC "-lc -lsim -lc -lhandlers-sim -lhal"
+#define LIB_SPEC "-lc -lnosys -lc"
 
 #undef STARTFILE_SPEC
 #define STARTFILE_SPEC \
-  "crt1-sim%O%s crt0%O%s crti%O%s crtbegin%O%s _vectors%O%s"
+  "crt0%O%s crti%O%s crtbegin%O%s"
 
 #undef ENDFILE_SPEC
 #define ENDFILE_SPEC "crtend%O%s crtn%O%s"  
diff --git a/gcc/config/xtensa/xtensa-opts.h b/gcc/config/xtensa/xtensa-opts.h
new file mode 100644
index 00000000000..f3073606ccb
--- /dev/null
+++ b/gcc/config/xtensa/xtensa-opts.h
@@ -0,0 +1,35 @@
+/* Definitions of option handling for Tensilica's Xtensa target machine.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   Contributed by Espressif <jeroen@espressif.com>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+
+#ifndef XTENSA_OPTS_H
+#define XTENSA_OPTS_H
+
+
+enum esp32_psram_fix_type
+{
+	ESP32_PSRAM_FIX_DUPLDST,
+	ESP32_PSRAM_FIX_MEMW,
+	ESP32_PSRAM_FIX_NOPS
+};
+
+
+#endif
\ No newline at end of file
diff --git a/gcc/config/xtensa/xtensa.c b/gcc/config/xtensa/xtensa.c
index 08f9f7c7a8f..77448d48421 100644
--- a/gcc/config/xtensa/xtensa.c
+++ b/gcc/config/xtensa/xtensa.c
@@ -55,6 +55,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "dumpfile.h"
 #include "hw-doloop.h"
 #include "rtl-iter.h"
+#include "tree-pass.h"
+#include "context.h"
+#include "insn-attr.h"
 
 /* This file should be included last.  */
 #include "target-def.h"
@@ -2204,6 +2207,333 @@ xtensa_return_in_msb (const_tree valtype)
 }
 
 
+#define USEFUL_INSN_P(INSN)                     \
+  (NONDEBUG_INSN_P (INSN)                       \
+   && GET_CODE (PATTERN (INSN)) != USE                  \
+   && GET_CODE (PATTERN (INSN)) != CLOBBER)
+
+/* If INSN is a delayed branch sequence, return the first instruction
+   in the sequence, otherwise return INSN itself.  */
+#define SEQ_BEGIN(INSN)							\
+  (INSN_P (INSN) && GET_CODE (PATTERN (INSN)) == SEQUENCE		\
+   ? as_a <rtx_insn *> (XVECEXP (PATTERN (INSN), 0, 0))			\
+   : (INSN))
+
+/* Likewise for the last instruction in a delayed branch sequence.  */
+#define SEQ_END(INSN)							\
+  (INSN_P (INSN) && GET_CODE (PATTERN (INSN)) == SEQUENCE		\
+   ? as_a <rtx_insn *> (XVECEXP (PATTERN (INSN),			\
+				 0,					\
+				 XVECLEN (PATTERN (INSN), 0) - 1))	\
+   : (INSN))
+
+/* Execute the following loop body with SUBINSN set to each instruction
+   between SEQ_BEGIN (INSN) and SEQ_END (INSN) inclusive.  */
+#define FOR_EACH_SUBINSN(SUBINSN, INSN)					\
+  for ((SUBINSN) = SEQ_BEGIN (INSN);					\
+       (SUBINSN) != NEXT_INSN (SEQ_END (INSN));				\
+       (SUBINSN) = NEXT_INSN (SUBINSN))
+
+
+
+/*
+Xtensa does a load/store inversion when a load and a store to the same address is found in the
+5 affected stages of the pipeline: with a load done _after_ the store in code, the Xtensa will move 
+it _before_ the store in execution. Unfortunately, the ESP32 PSRAM cache messes up handling these 
+when an interrupt happens during these. This reorg step inserts nops between loads and stores so 
+this never occurs.
+
+The handling issue also shows up when doing a store to an 8 or 16-bit memory location followed by
+a larger (16 or 32-bit) sized load from that location within the time it takes to grab a cache 
+line from external RAM (which is at least 80 cycles). The cache will confuse the load and store, 
+resulting in the bytes not set by thje store to be read as garbage. To fix this, we insert a 
+memory barrier after each 8/16-bit store that isn't followed by another store.
+*/
+
+//Affected piece of pipeline is 5 entries long; the load/store itself fills one.
+#define LOAD_STORE_OFF 4
+
+static int insns_since_store = 0;
+static rtx_insn *store_insn = NULL;
+static rtx_insn *last_hiqi_store=NULL;
+
+
+const char* attrstr[]={"TYPE_UNKNOWN", "TYPE_JUMP", 
+	"TYPE_CALL", "TYPE_LOAD", "TYPE_STORE", "TYPE_MOVE", "TYPE_ARITH", 
+	"TYPE_MULTI", "TYPE_NOP", "TYPE_FARITH", "TYPE_FMADD", "TYPE_FCONV", 
+	"TYPE_FLOAD", "TYPE_FSTORE", "TYPE_MUL16", "TYPE_MUL32", "TYPE_DIV32", 
+	"TYPE_MAC16", "TYPE_RSR", "TYPE_WSR", "TYPE_ENTRY", "TYPE_TRAP"};
+
+
+
+static void handle_fix_reorg_insn(rtx_insn *insn) {
+	enum attr_type attr_type = get_attr_type (insn);
+	if (attr_type == TYPE_STORE || attr_type == TYPE_FSTORE) {
+		rtx x=XEXP(PATTERN(insn), 0);
+		//Store
+		insns_since_store = 0;
+		store_insn = insn;
+		if (attr_type == TYPE_STORE && (GET_MODE(x)==HImode || GET_MODE(x)==QImode)) {
+			//This is an 16- or 8-bit store, record it.
+			last_hiqi_store=insn;
+		} else {
+			//32-bit store. This store undoes the possibility of badness in earlier 8/16-bit stores
+			//because it forces those stores to finish.
+			last_hiqi_store=NULL;
+		}
+	} else if (attr_type == TYPE_LOAD || attr_type == TYPE_FLOAD) {
+		//Load
+		if (store_insn) {
+			while (insns_since_store++ < LOAD_STORE_OFF) {
+				emit_insn_before (gen_nop(), insn);
+			}
+		}
+	} else if (attr_type == TYPE_JUMP || attr_type == TYPE_CALL) {
+		enum attr_condjmp attr_condjmp = get_attr_condjmp(insn);
+		if (attr_condjmp == CONDJMP_UNCOND) {
+			store_insn = NULL; //Pipeline gets cleared; any load is inconsequential
+		}
+	} else {
+		insns_since_store++;
+	}
+	if (attr_type == TYPE_LOAD || attr_type == TYPE_FLOAD || attr_type == TYPE_JUMP || attr_type == TYPE_CALL) {
+		if (last_hiqi_store) {
+			//Need to memory barrier the s8i/s16i instruction.
+			emit_insn_after(gen_memory_barrier(), last_hiqi_store);
+			last_hiqi_store=NULL;
+		}
+	}
+}
+
+static void xtensa_psram_cache_fix_nop_reorg()
+{
+	rtx_insn *insn, *subinsn, *next_insn;
+	for (insn = get_insns(); insn != 0; insn = next_insn) {
+		next_insn = NEXT_INSN (insn);
+		int  length = get_attr_length (insn);
+		
+		if (USEFUL_INSN_P (insn) && length>0  ) {
+			FOR_EACH_SUBINSN (subinsn, insn) {
+				handle_fix_reorg_insn(subinsn);
+			}
+		}
+	}
+}
+
+
+/*
+Alternative fix to xtensa_psram_cache_fix_reorg. Tries to solve the 32-bit load/store 
+inversion by explicitly inserting a memory barrier instead of nops. Slower than nops, but 
+faster than just adding memws everywhere.
+*/
+static void handle_fix_reorg_memw(rtx_insn *insn) {
+	enum attr_type attr_type = get_attr_type (insn);
+	rtx x=XEXP(PATTERN(insn), 0);
+	if (attr_type == TYPE_STORE || attr_type == TYPE_FSTORE) {
+		//Store
+		insns_since_store = 0;
+		store_insn = insn;
+		if (attr_type == TYPE_STORE && (GET_MODE(x)==HImode || GET_MODE(x)==QImode)) {
+			//This is an 16- or 8-bit store, record it if it's not volatile already.
+			if (!MEM_VOLATILE_P(x)) last_hiqi_store=insn;
+		}
+	} else if (attr_type == TYPE_LOAD || attr_type == TYPE_FLOAD) {
+		//Load
+		if (MEM_P(x) && (!MEM_VOLATILE_P(x))) {
+			if (store_insn) {
+				emit_insn_before(gen_memory_barrier(), insn);
+				store_insn=NULL;
+			}
+		}
+	} else if (attr_type == TYPE_JUMP || attr_type == TYPE_CALL) {
+		enum attr_condjmp attr_condjmp = get_attr_condjmp(insn);
+		if (attr_condjmp == CONDJMP_UNCOND) { //jump or return
+			//Unconditional jumps seem to not clear the pipeline, and there may be
+			//a load after. Need to memw if earlier code had a store.
+			if (store_insn) {
+				emit_insn_before(gen_memory_barrier(), insn);
+				store_insn = NULL;
+			}
+		}
+	} else {
+		insns_since_store++;
+	}
+	if (attr_type == TYPE_LOAD || attr_type == TYPE_FLOAD || attr_type == TYPE_JUMP || attr_type == TYPE_CALL) {
+		if (last_hiqi_store) {
+			//Need to memory barrier the s8i/s16i instruction.
+			emit_insn_after(gen_memory_barrier(), last_hiqi_store);
+			last_hiqi_store=NULL;
+		}
+	}
+}
+
+
+static void xtensa_psram_cache_fix_memw_reorg()
+{
+	rtx_insn *insn, *subinsn, *next_insn;
+	for (insn = get_insns(); insn != 0; insn = next_insn) {
+		next_insn = NEXT_INSN (insn);
+		int  length = get_attr_length (insn);
+		
+		if (USEFUL_INSN_P (insn) && length>0  ) {
+			FOR_EACH_SUBINSN (subinsn, insn) {
+				handle_fix_reorg_memw(subinsn);
+			}
+		}
+	}
+}
+
+
+/*
+Alternative fix to xtensa_psram_cache_fix_reorg. Tries to solve the 32-bit load/store 
+inversion by explicitly inserting a load after every store.
+
+For now, the logic is:
+- Instruction is s32i? Insert l32i from that address to the source register immediately after, plus a
+  duplicated s32i after that.
+- Instruction is s8i/s16i? Note and insert a memw before a load. (same as xtensa_psram_cache_fix_reorg)
+- If any of the args are volatile, no touchie: the memw resulting from that will fix everything.
+
+Note: debug_rtx(insn) can dump an insn in lisp-like format.
+*/
+
+static void xtensa_psram_cache_fix_dupldst_reorg()
+{
+	rtx_insn *insn, *subinsn, *next_insn;
+	rtx_insn *last_hiqi_store=NULL;
+	for (insn = get_insns(); insn != 0; insn = next_insn) {
+		next_insn = NEXT_INSN (insn);
+		int  length = get_attr_length (insn);
+		
+		if (USEFUL_INSN_P (insn) && length>0  ) {
+			FOR_EACH_SUBINSN (subinsn, insn) {
+
+				enum attr_type attr_type = get_attr_type (insn);
+				if (attr_type == TYPE_STORE || attr_type == TYPE_FSTORE) {
+					rtx x=XEXP(PATTERN(insn), 0);
+					//Store
+					if (attr_type == TYPE_STORE && (GET_MODE(x)==HImode || GET_MODE(x)==QImode)) {
+						//This is an 16- or 8-bit store, record it if it's not volatile already.
+						if (!MEM_VOLATILE_P(x)) last_hiqi_store=insn;
+					} else { //32-bit store
+						//Add a load-after-store to fix psram issues *if* var is not volatile
+						if (MEM_P(x) && (!MEM_VOLATILE_P(x))) {
+							rtx y=XEXP(PATTERN(insn), 1);
+							if (REG_P(y) && XINT(y, 0)==1) {
+								//store SP in mem? Can't movsi that back. Insert memory barrier instead.
+								emit_insn_after(gen_memory_barrier(), insn);
+							} else {
+								//add the load/store
+								//Note that the instructions will be added in the OPPOSITE order as the instructions are added between
+								//the s32i and the next instruction. So 1: s32i(insn), s32i; 2:s32i(insn), l32i, s32i.
+								emit_insn_after(gen_movsi(XEXP(PATTERN(insn), 0), XEXP(PATTERN(insn), 1)), insn); //store again
+								emit_insn_after(gen_movsi(XEXP(PATTERN(insn), 1), XEXP(PATTERN(insn), 0)), insn); //load
+							}
+						}
+					}
+				}
+
+				if (attr_type == TYPE_LOAD || attr_type == TYPE_FLOAD || attr_type == TYPE_JUMP || attr_type == TYPE_CALL) {
+					if (last_hiqi_store) {
+						//Need to memory barrier the s8i/s16i instruction.
+						emit_insn_after(gen_memory_barrier(), last_hiqi_store);
+						last_hiqi_store=NULL;
+					}
+				}
+			}
+		}
+	}
+}
+
+//Emits a memw before every load/store instruction. Hard-handed approach to get rid
+//of any pipeline/memory issues...
+static void xtensa_insert_memw_reorg()
+{
+	rtx_insn *insn, *subinsn, *next_insn;
+	int had_memw=0;
+	for (insn = get_insns(); insn != 0; insn = next_insn) {
+		next_insn = NEXT_INSN (insn);
+		int length = get_attr_length (insn);
+		
+		if (USEFUL_INSN_P (insn) && length>0) {
+			FOR_EACH_SUBINSN (subinsn, insn) {
+				rtx x=XEXP(PATTERN(subinsn), 0);
+				enum attr_type attr_type = get_attr_type (subinsn);
+				if (attr_type == TYPE_STORE) {
+					if (MEM_P(x) && (!MEM_VOLATILE_P(x))) {
+						emit_insn_after(gen_memory_barrier(), subinsn);
+					}
+					had_memw=1;
+				} else if (attr_type == TYPE_LOAD) {
+					if (MEM_P(x) && (!MEM_VOLATILE_P(x)) && !had_memw) {
+						emit_insn_before(gen_memory_barrier(), subinsn);
+					}
+					had_memw=0;
+				} else {
+					had_memw=0;
+				}
+			}
+		}
+	}
+}
+
+static unsigned int xtensa_machine_reorg(void) {
+	if (TARGET_ESP32_ALWAYS_MEMBARRIER) {
+		xtensa_insert_memw_reorg();
+	}
+	if (TARGET_ESP32_PSRAM_FIX_ENA) {
+		if (esp32_psram_fix_strat==ESP32_PSRAM_FIX_DUPLDST) {
+			xtensa_psram_cache_fix_dupldst_reorg();
+		} else if (esp32_psram_fix_strat==ESP32_PSRAM_FIX_MEMW) {
+			xtensa_psram_cache_fix_memw_reorg();
+		} else if (esp32_psram_fix_strat==ESP32_PSRAM_FIX_NOPS) {
+			xtensa_psram_cache_fix_nop_reorg();
+		} else {
+			//default to memw (note: 5.2.x defaulted to nops)
+			xtensa_psram_cache_fix_memw_reorg();
+		}
+	}
+	return 0;
+}
+
+
+namespace {
+
+const pass_data pass_data_xtensa_psram_nops =
+{
+  RTL_PASS, /* type */
+  "xtensa-psram-adj", /* name */
+  OPTGROUP_NONE, /* optinfo_flags */
+  TV_MACH_DEP, /* tv_id */
+  0, /* properties_required */
+  0, /* properties_provided */
+  0, /* properties_destroyed */
+  0, /* todo_flags_start */
+  0, /* todo_flags_finish */
+};
+
+class pass_xtensa_psram_nops : public rtl_opt_pass
+{
+public:
+  pass_xtensa_psram_nops(gcc::context *ctxt)
+    : rtl_opt_pass(pass_data_xtensa_psram_nops, ctxt)
+  {}
+
+  /* opt_pass methods: */
+  virtual unsigned int execute (function *) { return xtensa_machine_reorg (); }
+
+}; // class pass_mips_machine_reorg2
+
+} // anon namespace
+
+rtl_opt_pass *
+make_pass_xtensa_psram_nops (gcc::context *ctxt)
+{
+  return new pass_xtensa_psram_nops (ctxt);
+}
+
+
+
 static void
 xtensa_option_override (void)
 {
@@ -2269,6 +2599,19 @@ xtensa_option_override (void)
   if (flag_pic && !flag_pie)
     flag_shlib = 1;
 
+  /* Register machine specific reorg for optional nop insertion to
+     fix psram cache bug on esp32 v0/v1 silicon  */
+  opt_pass *new_pass = make_pass_xtensa_psram_nops (g);
+  struct register_pass_info insert_pass_xtensa_psram_nops =
+    {
+      new_pass,		/* pass */
+      "dbr",			/* reference_pass_name */
+      1,			/* ref_pass_instance_number */
+      PASS_POS_INSERT_AFTER	/* po_op */
+    };
+  register_pass (&insert_pass_xtensa_psram_nops);
+
+
   /* Hot/cold partitioning does not work on this architecture, because of
      constant pools (the load instruction cannot necessarily reach that far).
      Therefore disable it on this architecture.  */
@@ -4256,7 +4599,10 @@ hwloop_optimize (hwloop_info loop)
       entry_after = BB_END (entry_bb);
       while (DEBUG_INSN_P (entry_after)
              || (NOTE_P (entry_after)
-		 && NOTE_KIND (entry_after) != NOTE_INSN_BASIC_BLOCK))
+                 && NOTE_KIND (entry_after) != NOTE_INSN_BASIC_BLOCK
+         /* Make sure we don't split a call and its corresponding
+            CALL_ARG_LOCATION note.  */
+                 && NOTE_KIND (entry_after) != REG_CALL_ARG_LOCATION))
         entry_after = PREV_INSN (entry_after);
 
       emit_insn_after (seq, entry_after);
diff --git a/gcc/config/xtensa/xtensa.h b/gcc/config/xtensa/xtensa.h
index 193eed61978..c1f74cf7936 100644
--- a/gcc/config/xtensa/xtensa.h
+++ b/gcc/config/xtensa/xtensa.h
@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see
 
 /* Get Xtensa configuration settings */
 #include "xtensa-config.h"
+#include "xtensa-opts.h"
 
 /* External variables defined in xtensa.c.  */
 
@@ -128,6 +129,10 @@ along with GCC; see the file COPYING3.  If not see
 #define DOUBLE_TYPE_SIZE 64
 #define LONG_DOUBLE_TYPE_SIZE 64
 
+/* Use int, instead of long int, for int32_t and uint32_t.  */
+#undef STDINT_LONG32
+#define STDINT_LONG32 0
+
 /* Allocation boundary (in *bits*) for storing pointers in memory.  */
 #define POINTER_BOUNDARY 32
 
diff --git a/gcc/config/xtensa/xtensa.md b/gcc/config/xtensa/xtensa.md
index 209f839cfb0..d2178ca7ef2 100644
--- a/gcc/config/xtensa/xtensa.md
+++ b/gcc/config/xtensa/xtensa.md
@@ -94,6 +94,10 @@
   "unknown,none,QI,HI,SI,DI,SF,DF,BL"
   (const_string "unknown"))
 
+(define_attr "condjmp"
+  "na,cond,uncond"
+  (const_string "na"))
+
 (define_attr "length" "" (const_int 1))
 
 ;; Describe a user's asm statement.
@@ -109,14 +113,38 @@
 ;; reservations in the pipeline description below.  The Xtensa can
 ;; issue one instruction per cycle, so defining CPU units is unnecessary.
 
+(define_cpu_unit "loadstore")
+
 (define_insn_reservation "xtensa_any_insn" 1
-			 (eq_attr "type" "!load,fload,rsr,mul16,mul32,fmadd,fconv")
+			 (eq_attr "type" "!load,fload,store,fstore,rsr,mul16,mul32,fmadd,fconv")
+			 "nothing")
+
+(define_insn_reservation "xtensa_memory_load" 2
+			 (and (not (match_test "TARGET_ESP32_PSRAM_FIX_ENA"))
+			 (eq_attr "type" "load,fload"))
 			 "nothing")
 
-(define_insn_reservation "xtensa_memory" 2
-			 (eq_attr "type" "load,fload")
+(define_insn_reservation "xtensa_memory_store" 1
+			 (and (not (match_test "TARGET_ESP32_PSRAM_FIX_ENA"))
+			 (eq_attr "type" "store,fstore"))
 			 "nothing")
 
+;; If psram cache issue needs fixing, it's better to keep 
+;; stores far from loads from the same address. We cannot encode
+;; that behaviour entirely here (or maybe we can, but at least 
+;; not easily), but we can try to get everything that smells like 
+;; load or store up to a pipeline length apart from each other.
+
+(define_insn_reservation "xtensa_memory_load_psram_fix" 2
+			 (and (match_test "TARGET_ESP32_PSRAM_FIX_ENA")
+			 (eq_attr "type" "load,fload"))
+			 "loadstore*5")
+
+(define_insn_reservation "xtensa_memory_store_psram_fix" 1
+			 (and (match_test "TARGET_ESP32_PSRAM_FIX_ENA")
+			 (eq_attr "type" "store,fstore"))
+			 "loadstore*5")
+
 (define_insn_reservation "xtensa_sreg" 2
 			 (eq_attr "type" "rsr")
 			 "nothing")
@@ -1159,6 +1187,7 @@
 }
   [(set_attr "type"	"jump,jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3,3")])
 
 (define_insn "*bfalse"
@@ -1174,6 +1203,7 @@
 }
   [(set_attr "type"	"jump,jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3,3")])
 
 (define_insn "*ubtrue"
@@ -1189,6 +1219,7 @@
 }
   [(set_attr "type"	"jump,jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3,3")])
 
 (define_insn "*ubfalse"
@@ -1204,6 +1235,7 @@
 }
   [(set_attr "type"	"jump,jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3,3")])
 
 ;; Branch patterns for bit testing
@@ -1224,6 +1256,7 @@
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3")])
 
 (define_insn "*bitfalse"
@@ -1242,6 +1275,7 @@
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3")])
 
 (define_insn "*masktrue"
@@ -1263,6 +1297,7 @@
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3")])
 
 (define_insn "*maskfalse"
@@ -1284,6 +1319,7 @@
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3")])
 
 
@@ -1308,6 +1344,7 @@
   "loop\t%0, %l1_LEND"
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3")])
 
 (define_insn "zero_cost_loop_end"
@@ -1344,6 +1381,7 @@
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"0")])
 
 (define_split
@@ -1541,6 +1579,7 @@
   "j\t%l0"
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "uncond")
    (set_attr "length"	"3")])
 
 (define_expand "indirect_jump"
@@ -1562,6 +1601,7 @@
   "jx\t%0"
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "uncond")
    (set_attr "length"	"3")])
 
 
@@ -1591,6 +1631,7 @@
   "jx\t%0"
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "uncond")
    (set_attr "length"	"3")])
 
 
@@ -1623,6 +1664,7 @@
 }
   [(set_attr "type"	"call")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "uncond")
    (set_attr "length"	"3")])
 
 (define_expand "call_value"
@@ -1649,6 +1691,7 @@
 }
   [(set_attr "type"	"call")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "uncond")
    (set_attr "length"	"3")])
 
 (define_insn "entry"
@@ -1672,6 +1715,7 @@
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "uncond")
    (set_attr "length"	"2")])
 
 
@@ -1958,6 +2002,7 @@
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3")])
 
 (define_insn "*boolfalse"
@@ -1976,6 +2021,7 @@
 }
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")
+   (set_attr "condjmp" "cond")
    (set_attr "length"	"3")])
 
 
diff --git a/gcc/config/xtensa/xtensa.opt b/gcc/config/xtensa/xtensa.opt
index 4d3f941281c..fec750d8ca8 100644
--- a/gcc/config/xtensa/xtensa.opt
+++ b/gcc/config/xtensa/xtensa.opt
@@ -18,6 +18,9 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
+HeaderInclude
+config/xtensa/xtensa-opts.h
+
 mconst16
 Target Report Mask(CONST16)
 Use CONST16 instruction to load constants.
@@ -45,3 +48,32 @@ Relax literals in assembler and place them automatically in the text section.
 mserialize-volatile
 Target Report Mask(SERIALIZE_VOLATILE)
 -mno-serialize-volatile	Do not serialize volatile memory references with MEMW instructions.
+
+malways-memw
+Target Report Mask(ESP32_ALWAYS_MEMBARRIER)
+Always emit a MEMW before a load and after a store operation. Used to debug memory coherency issues.
+
+mfix-esp32-psram-cache-issue
+Target Report Mask(ESP32_PSRAM_FIX_ENA)
+Work around a PSRAM cache issue in the ESP32 ECO1 chips.
+
+mfix-esp32-psram-cache-strategy=
+Target RejectNegative JoinedOrMissing Enum(esp32_psram_fix_type) Var(esp32_psram_fix_strat) Init(ESP32_PSRAM_FIX_MEMW)
+Specify a psram cache fix strategy.
+
+Enum
+Name(esp32_psram_fix_type) Type(enum esp32_psram_fix_type)
+Psram cache fix strategies (for use with -mfix-esp32-psram-cache-strategy= option):
+
+EnumValue
+Enum(esp32_psram_fix_type) String(dupldst) Value(ESP32_PSRAM_FIX_DUPLDST)
+Fix esp32 psram cache issue by duplicating stores and non-word loads. Default workaround.
+
+EnumValue
+Enum(esp32_psram_fix_type) String(memw) Value(ESP32_PSRAM_FIX_MEMW)
+Fix esp32 psram cache issue by inserting memory barriers in critical places (alternative workaround).
+
+EnumValue
+Enum(esp32_psram_fix_type) String(nops) Value(ESP32_PSRAM_FIX_NOPS)
+Fix esp32 psram cache issue by inserting NOPs in critical places.
+
diff --git a/gcc/configure b/gcc/configure
index 97ba7d7d69c..a8af9d215e9 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -944,6 +944,7 @@ enable_fix_cortex_a53_835769
 enable_fix_cortex_a53_843419
 with_glibc_version
 enable_gnu_unique_object
+enable_eh_frame_hdr_for_static
 enable_linker_build_id
 enable_libssp
 enable_default_ssp
@@ -1685,6 +1686,9 @@ Optional Features:
   --enable-gnu-unique-object
                           enable the use of the @gnu_unique_object ELF
                           extension on glibc systems
+  --enable-eh-frame-hdr-for-static
+                          enable linker PT_GNU_EH_FRAME support for static
+                          executable
   --enable-linker-build-id
                           compiler will always pass --build-id to linker
   --enable-libssp         enable linking against libssp
@@ -28316,6 +28320,38 @@ if test x"$gcc_cv_ld_eh_frame_hdr" = xyes; then
 
 $as_echo "#define HAVE_LD_EH_FRAME_HDR 1" >>confdefs.h
 
+  # Check whether --enable-eh-frame-hdr-for-static was given.
+if test "${enable_eh_frame_hdr_for_static+set}" = set; then :
+  enableval=$enable_eh_frame_hdr_for_static; case $enable_eh_frame_hdr_for_static in
+    yes | no) ;;
+    *) as_fn_error "'$enable_eh_frame_hdr_for_static' is an invalid
+value for --enable-eh-frame-hdr-for-static.
+Valid choices are 'yes' and 'no'." "$LINENO" 5 ;;
+    esac
+else
+  # Only support for glibc 2.3.0 or higher with AT_PHDR/AT_PHNUM from
+# Linux kernel.
+   if test x$host = x$build -a x$host = x$target &&
+       ldd --version 2>&1 >/dev/null &&
+       glibcver=`ldd --version 2>/dev/null | sed 's/.* //;q'`; then
+      glibcmajor=`expr "$glibcver" : "\([0-9]*\)"`
+      glibcminor=`expr "$glibcver" : "[2-9]*\.\([0-9]*\)"`
+      glibcnum=`expr $glibcmajor \* 1000 + $glibcminor`
+      if test "$glibcnum" -ge 2003 ; then
+	auvx=`LD_SHOW_AUXV=1 ldd 2>/dev/null`
+	if echo "$auvx" | grep AT_PHDR > /dev/null &&
+	   echo "$auvx" | grep AT_PHNUM > /dev/null; then
+	  enable_eh_frame_hdr_for_static=yes
+	fi
+      fi
+    fi
+fi
+
+  if test x$enable_eh_frame_hdr_for_static = xyes; then
+
+$as_echo "#define USE_EH_FRAME_HDR_FOR_STATIC 1" >>confdefs.h
+
+  fi
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_ld_eh_frame_hdr" >&5
 $as_echo "$gcc_cv_ld_eh_frame_hdr" >&6; }
@@ -29805,6 +29841,9 @@ fi
    pluginlibs=
    plugin_check=yes
 
+   PICFLAG="-fPIC"
+   UNDEFINEDPREAMBLE="extern int X;"
+   UNDEFINEDCODE="return X == 0;"
    case "${host}" in
      *-*-mingw*)
        # Since plugin support under MinGW is not as straightforward as on
@@ -29827,6 +29866,11 @@ fi
 	 export_sym_check=
        fi
      ;;
+     *-*-mingw*|*-*-cygwin*|*-*-msys*)
+       PICFLAG=""
+       UNDEFINEDPREAMBLE=""
+       UNDEFINEDCODE=""
+     ;;
      *)
        if test x$build = x$host; then
 	 export_sym_check="objdump${exeext} -T"
@@ -29939,23 +29983,23 @@ fi
      case "${host}" in
        *-*-darwin*)
 	 CFLAGS=`echo $CFLAGS | sed s/-mdynamic-no-pic//g`
-	 CFLAGS="$CFLAGS -fPIC"
+	 CFLAGS="$CFLAGS ${PICFLAG}"
 	 LDFLAGS="$LDFLAGS -shared -undefined dynamic_lookup"
        ;;
        *)
-	 CFLAGS="$CFLAGS -fPIC"
-	 LDFLAGS="$LDFLAGS -fPIC -shared"
+	 CFLAGS="$CFLAGS ${PICFLAG}"
+	 LDFLAGS="$LDFLAGS ${PICFLAG} -shared"
        ;;
      esac
-     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -fPIC -shared" >&5
-$as_echo_n "checking for -fPIC -shared... " >&6; }
+     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${PICFLAG} -shared" >&5
+$as_echo_n "checking for ${PICFLAG} -shared... " >&6; }
      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-extern int X;
+${UNDEFINEDPREAMBLE}
 int
 main ()
 {
-return X == 0;
+${UNDEFINEDCODE}
   ;
   return 0;
 }
diff --git a/gcc/configure.ac b/gcc/configure.ac
index d6f2d5b2ed0..3cc88cf1d96 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -5136,6 +5136,35 @@ GCC_TARGET_TEMPLATE([HAVE_LD_EH_FRAME_HDR])
 if test x"$gcc_cv_ld_eh_frame_hdr" = xyes; then
 	AC_DEFINE(HAVE_LD_EH_FRAME_HDR, 1,
 [Define if your linker supports .eh_frame_hdr.])
+  AC_ARG_ENABLE(eh-frame-hdr-for-static,
+   [AS_HELP_STRING([--enable-eh-frame-hdr-for-static],
+     [enable linker PT_GNU_EH_FRAME support for static executable])],
+   [case $enable_eh_frame_hdr_for_static in
+    yes | no) ;;
+    *) AC_MSG_ERROR(['$enable_eh_frame_hdr_for_static' is an invalid
+value for --enable-eh-frame-hdr-for-static.
+Valid choices are 'yes' and 'no'.]) ;;
+    esac],
+# Only support for glibc 2.3.0 or higher with AT_PHDR/AT_PHNUM from
+# Linux kernel.
+   [[if test x$host = x$build -a x$host = x$target &&
+       ldd --version 2>&1 >/dev/null &&
+       glibcver=`ldd --version 2>/dev/null | sed 's/.* //;q'`; then
+      glibcmajor=`expr "$glibcver" : "\([0-9]*\)"`
+      glibcminor=`expr "$glibcver" : "[2-9]*\.\([0-9]*\)"`
+      glibcnum=`expr $glibcmajor \* 1000 + $glibcminor`
+      if test "$glibcnum" -ge 2003 ; then
+	auvx=`LD_SHOW_AUXV=1 ldd 2>/dev/null`
+	if echo "$auvx" | grep AT_PHDR > /dev/null &&
+	   echo "$auvx" | grep AT_PHNUM > /dev/null; then
+	  enable_eh_frame_hdr_for_static=yes
+	fi
+      fi
+    fi]])
+  if test x$enable_eh_frame_hdr_for_static = xyes; then
+    AC_DEFINE(USE_EH_FRAME_HDR_FOR_STATIC, 1,
+[Define if your system supports PT_GNU_EH_FRAME for static executable.])
+  fi
 fi
 AC_MSG_RESULT($gcc_cv_ld_eh_frame_hdr)
 
diff --git a/gcc/testsuite/g++.dg/eh/spec3-static.C b/gcc/testsuite/g++.dg/eh/spec3-static.C
new file mode 100644
index 00000000000..15408effa74
--- /dev/null
+++ b/gcc/testsuite/g++.dg/eh/spec3-static.C
@@ -0,0 +1,25 @@
+// PR c++/4381
+// Test that exception-specs work properly for classes with virtual bases.
+
+// { dg-do run }
+// { dg-options "-static" }
+
+class Base {};
+
+struct A : virtual public Base
+{
+  A() {}
+};
+
+struct B {};
+
+void func() throw (B,A)
+{
+  throw A();
+}
+
+int main(void)
+{
+  try {	func(); }
+  catch (A& a) { }
+}
diff --git a/gcc/testsuite/g++.target/xtensa/pr95571.C b/gcc/testsuite/g++.target/xtensa/pr95571.C
new file mode 100644
index 00000000000..59fe2852838
--- /dev/null
+++ b/gcc/testsuite/g++.target/xtensa/pr95571.C
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+
+extern "C" void abort(void);
+extern "C" void __xtensa_libgcc_window_spill(void);
+
+static int call;
+static int cnt;
+
+extern "C" void *memcpy(void *dst, const void *src, unsigned int sz)
+{
+  char *a = (char *)dst;
+  const char *b = (const char *)src;
+
+  if (call++ == cnt)
+    __xtensa_libgcc_window_spill();
+
+  while (sz--)
+    *a++ = *b++;
+
+  return dst;
+}
+
+int main()
+{
+  int i;
+
+  for (i = 0; i < 100; ++i)
+    {
+      call = 0;
+      cnt = i;
+
+      try
+	{
+	  throw 1;
+	}
+      catch (int v)
+	{
+	  if (v != 1)
+	    abort ();
+	}
+    }
+  return 0;
+}
diff --git a/gcc/testsuite/g++.target/xtensa/xtensa.exp b/gcc/testsuite/g++.target/xtensa/xtensa.exp
new file mode 100644
index 00000000000..f4191201d11
--- /dev/null
+++ b/gcc/testsuite/g++.target/xtensa/xtensa.exp
@@ -0,0 +1,43 @@
+#  Specific regression driver for Xtensa.
+#  Copyright (C) 2020 Free Software Foundation, Inc.
+#
+#  This file is part of GCC.
+#
+#  GCC is free software; you can redistribute it and/or modify it
+#  under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 3, or (at your option)
+#  any later version.
+#
+#  GCC is distributed in the hope that it will be useful, but
+#  WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#  General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GCC; see the file COPYING3.  If not see
+#  <http://www.gnu.org/licenses/>.  */
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't an Xtensa target.
+if {![istarget xtensa*-*-*] } then {
+  return
+}
+
+# Load support procs.
+load_lib g++-dg.exp
+
+global DEFAULT_CXXFLAGS
+if ![info exists DEFAULT_CXXFLAGS] then {
+    set DEFAULT_CXXFLAGS " -pedantic-errors"
+}
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \
+        "" $DEFAULT_CXXFLAGS
+
+# All done.
+dg-finish
diff --git a/libcc1/configure b/libcc1/configure
index f53a121611c..051dd8075b8 100755
--- a/libcc1/configure
+++ b/libcc1/configure
@@ -14554,6 +14554,9 @@ fi
    pluginlibs=
    plugin_check=yes
 
+   PICFLAG="-fPIC"
+   UNDEFINEDPREAMBLE="extern int X;"
+   UNDEFINEDCODE="return X == 0;"
    case "${host}" in
      *-*-mingw*)
        # Since plugin support under MinGW is not as straightforward as on
@@ -14576,6 +14579,11 @@ fi
 	 export_sym_check=
        fi
      ;;
+     *-*-mingw*|*-*-cygwin*|*-*-msys*)
+       PICFLAG=""
+       UNDEFINEDPREAMBLE=""
+       UNDEFINEDCODE=""
+     ;;
      *)
        if test x$build = x$host; then
 	 export_sym_check="objdump${exeext} -T"
@@ -14688,23 +14696,23 @@ fi
      case "${host}" in
        *-*-darwin*)
 	 CFLAGS=`echo $CFLAGS | sed s/-mdynamic-no-pic//g`
-	 CFLAGS="$CFLAGS -fPIC"
+	 CFLAGS="$CFLAGS ${PICFLAG}"
 	 LDFLAGS="$LDFLAGS -shared -undefined dynamic_lookup"
        ;;
        *)
-	 CFLAGS="$CFLAGS -fPIC"
-	 LDFLAGS="$LDFLAGS -fPIC -shared"
+	 CFLAGS="$CFLAGS ${PICFLAG}"
+	 LDFLAGS="$LDFLAGS ${PICFLAG} -shared"
        ;;
      esac
-     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -fPIC -shared" >&5
-$as_echo_n "checking for -fPIC -shared... " >&6; }
+     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${PICFLAG} -shared" >&5
+$as_echo_n "checking for ${PICFLAG} -shared... " >&6; }
      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-extern int X;
+${UNDEFINEDPREAMBLE}
 int
 main ()
 {
-return X == 0;
+${UNDEFINEDCODE}
   ;
   return 0;
 }
diff --git a/libcc1/connection.cc b/libcc1/connection.cc
index ee395149756..5e9fd80085e 100644
--- a/libcc1/connection.cc
+++ b/libcc1/connection.cc
@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see
 #include <string>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/select.h>
 #include <string.h>
 #include <errno.h>
 #include "marshall.hh"
diff --git a/libgcc/config.host b/libgcc/config.host
index b12c86267da..6a83aa29038 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -847,7 +847,7 @@ m68k*-*-netbsdelf*)
 m68k*-*-openbsd*)
 	;;
 m68k-*-uclinux*)	# Motorola m68k/ColdFire running uClinux with uClibc
-	tmake_file="$tmake_file m68k/t-floatlib m68k/t-linux"
+	tmake_file="$tmake_file m68k/t-floatlib"
 	md_unwind_header=m68k/linux-unwind.h
 	;;
 m68k-*-linux*)			# Motorola m68k's running GNU/Linux
diff --git a/libgcc/config/t-stack b/libgcc/config/t-stack
index cc0366b4cd8..f3f97e86d60 100644
--- a/libgcc/config/t-stack
+++ b/libgcc/config/t-stack
@@ -1,4 +1,6 @@
 # Makefile fragment to provide generic support for -fsplit-stack.
 # This should be used in config.host for any host which supports
 # -fsplit-stack.
+ifeq ($(enable_threads),yes)
 LIB2ADD_ST += $(srcdir)/generic-morestack.c $(srcdir)/generic-morestack-thread.c
+endif
diff --git a/libgcc/config/xtensa/unwind-dw2-xtensa.c b/libgcc/config/xtensa/unwind-dw2-xtensa.c
index d6352498d8f..037785473b0 100644
--- a/libgcc/config/xtensa/unwind-dw2-xtensa.c
+++ b/libgcc/config/xtensa/unwind-dw2-xtensa.c
@@ -481,37 +481,35 @@ uw_init_context_1 (struct _Unwind_Context *context, void *outer_cfa,
 
 /* Install TARGET into CURRENT so that we can return to it.  This is a
    macro because __builtin_eh_return must be invoked in the context of
-   our caller.  */
+   our caller, and also because spilling registers of the caller before
+   the context installation may result in reload of wrong register values
+   after the context installation due to the change of the stack pointer
+   in the base save area.  This spilling may be caused by an interrupt
+   handler on baremetal host.  */
 
-#define uw_install_context(CURRENT, TARGET, FRAMES)				 \
+#define uw_install_context(CURRENT, TARGET, FRAMES)			 \
   do									 \
     {									 \
-      long offset = uw_install_context_1 ((CURRENT), (TARGET));		 \
       void *handler = __builtin_frob_return_addr ((TARGET)->ra);	 \
-      __builtin_eh_return (offset, handler);				 \
+      long i;								 \
+									 \
+      /* The eh_return insn assumes a window size of 8, so don't bother	 \
+	 copying the save areas for registers a8-a15 since they won't be \
+	 reloaded.  */							 \
+      for (i = 0; i < 2; ++i)						 \
+	{								 \
+	  _Unwind_Word *c = (CURRENT)->reg[i];				 \
+	  _Unwind_Word *t = (TARGET)->reg[i];				 \
+	  int j;							 \
+									 \
+	  if (t && c && t != c)						 \
+	    for (j = 0; j < 4; ++j)					 \
+	      *c++ = *t++;						 \
+	}								 \
+      __builtin_eh_return (0, handler);					 \
     }									 \
   while (0)
 
-static long
-uw_install_context_1 (struct _Unwind_Context *current,
-		      struct _Unwind_Context *target)
-{
-  long i;
-
-  /* The eh_return insn assumes a window size of 8, so don't bother copying
-     the save areas for registers a8-a15 since they won't be reloaded.  */
-  for (i = 0; i < 2; ++i)
-    {
-      void *c = current->reg[i];
-      void *t = target->reg[i];
-
-      if (t && c && t != c)
-	memcpy (c, t, 4 * sizeof (_Unwind_Word));
-    }
-
-  return 0;
-}
-
 static inline _Unwind_Ptr
 uw_identify_context (struct _Unwind_Context *context)
 {
diff --git a/libgcc/crtstuff.c b/libgcc/crtstuff.c
index 5e894455e16..a4b2c973c1a 100644
--- a/libgcc/crtstuff.c
+++ b/libgcc/crtstuff.c
@@ -88,7 +88,8 @@ call_ ## FUNC (void)					\
 #if defined(OBJECT_FORMAT_ELF) \
     && !defined(OBJECT_FORMAT_FLAT) \
     && defined(HAVE_LD_EH_FRAME_HDR) \
-    && !defined(inhibit_libc) && !defined(CRTSTUFFT_O) \
+    && !defined(inhibit_libc) \
+    && (defined(USE_EH_FRAME_HDR_FOR_STATIC) || !defined(CRTSTUFFT_O)) \
     && defined(BSD_DL_ITERATE_PHDR_AVAILABLE)
 #include <link.h>
 # define USE_PT_GNU_EH_FRAME
@@ -97,7 +98,8 @@ call_ ## FUNC (void)					\
 #if defined(OBJECT_FORMAT_ELF) \
     && !defined(OBJECT_FORMAT_FLAT) \
     && defined(HAVE_LD_EH_FRAME_HDR) && defined(TARGET_DL_ITERATE_PHDR) \
-    && !defined(inhibit_libc) && !defined(CRTSTUFFT_O) \
+    && !defined(inhibit_libc) \
+    && (defined(USE_EH_FRAME_HDR_FOR_STATIC) || !defined(CRTSTUFFT_O)) \
     && defined(__sun__) && defined(__svr4__)
 #include <link.h>
 # define USE_PT_GNU_EH_FRAME
@@ -106,7 +108,8 @@ call_ ## FUNC (void)					\
 #if defined(OBJECT_FORMAT_ELF) \
     && !defined(OBJECT_FORMAT_FLAT) \
     && defined(HAVE_LD_EH_FRAME_HDR) \
-    && !defined(inhibit_libc) && !defined(CRTSTUFFT_O) \
+    && !defined(inhibit_libc) \
+    && (defined(USE_EH_FRAME_HDR_FOR_STATIC) || !defined(CRTSTUFFT_O)) \
     && defined(__GLIBC__) && __GLIBC__ >= 2
 #include <link.h>
 /* uClibc pretends to be glibc 2.2 and DT_CONFIG is defined in its link.h.
@@ -121,7 +124,7 @@ call_ ## FUNC (void)					\
 #if defined(OBJECT_FORMAT_ELF) \
     && !defined(OBJECT_FORMAT_FLAT) \
     && defined(HAVE_LD_EH_FRAME_HDR) \
-    && !defined(CRTSTUFFT_O) \
+    && (defined(USE_EH_FRAME_HDR_FOR_STATIC) || !defined(CRTSTUFFT_O)) \
     && defined(inhibit_libc) \
     && (defined(__GLIBC__) || defined(__gnu_linux__) || defined(__GNU__))
 /* On systems using glibc, an inhibit_libc build of libgcc is only
diff --git a/libgcc/gthr-posix.h b/libgcc/gthr-posix.h
index e2f952f6c1c..a8d638396b9 100644
--- a/libgcc/gthr-posix.h
+++ b/libgcc/gthr-posix.h
@@ -32,6 +32,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define __GTHREADS 1
 #define __GTHREADS_CXX0X 1
 
+/* The following should normally be in a different header file,
+ * but I couldn't find the right location. The point of the macro
+ * definition below is to prevent libsupc++ and libstdc++ to reference
+ * weak symbols in their static C++ constructors. Such code crashes
+ * when a shared object linked statically to these libraries is
+ * loaded on Android 2.1 (Eclair) and older platform releases, due
+ * to a dynamic linker bug.
+ */
+#ifdef __ANDROID__
+#undef GTHREAD_USE_WEAK
+#define GTHREAD_USE_WEAK 0
+#endif
+
 #include <pthread.h>
 
 #if ((defined(_LIBOBJC) || defined(_LIBOBJC_WEAK)) \
diff --git a/libgcc/gthr.h b/libgcc/gthr.h
index 88b0178f9e3..1254a1f26fa 100644
--- a/libgcc/gthr.h
+++ b/libgcc/gthr.h
@@ -145,7 +145,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define GTHREAD_USE_WEAK 1
 #endif
 #endif
+#if __ANDROID__
+#include "gthr-posix.h"
+#else
 #include "gthr-default.h"
+#endif
 
 #ifndef HIDE_EXPORTS
 #pragma GCC visibility pop
diff --git a/libgcc/unwind-dw2-fde.c b/libgcc/unwind-dw2-fde.c
index 0d52b7a4cef..a7d4347b2de 100644
--- a/libgcc/unwind-dw2-fde.c
+++ b/libgcc/unwind-dw2-fde.c
@@ -79,6 +79,12 @@ static __gthread_mutex_t object_mutex;
 #endif
 #endif
 
+static unsigned char enable_exception_fde_sorting = 1;
+
+void _Unwind_SetEnableExceptionFdeSorting(unsigned char enable) {
+    enable_exception_fde_sorting = enable;
+}
+
 /* Called from crtbegin.o to register the unwind info for an object.  */
 
 void
@@ -796,6 +802,9 @@ init_object (struct object* ob)
 	ob->s.b.count = 0;
     }
 
+  if (!enable_exception_fde_sorting)
+    return;
+
   if (!start_fde_sort (&accu, count))
     return;
 
diff --git a/libgcc/unwind-dw2-fde.h b/libgcc/unwind-dw2-fde.h
index 88e8028111b..b56ae7e2aea 100644
--- a/libgcc/unwind-dw2-fde.h
+++ b/libgcc/unwind-dw2-fde.h
@@ -89,6 +89,7 @@ struct dwarf_eh_bases
   void *func;
 };
 
+void _Unwind_SetEnableExceptionFdeSorting(unsigned char enable);
 
 extern void __register_frame_info_bases (const void *, struct object *,
 					 void *, void *);
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index b380a2628c1..974dad79d96 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -1445,6 +1445,13 @@ AC_DEFUN([GLIBCXX_ENABLE_LIBSTDCXX_TIME], [
         ;;
     esac
 
+  elif test x"$enable_libstdcxx_time" = x"yes"; then
+    # xtensa-esp32: This sets the same settings for canadian cross and native builds
+    ac_has_clock_monotonic=yes
+    ac_has_clock_realtime=yes
+    ac_has_nanosleep=no
+    ac_has_sched_yield=yes
+
   elif test x"$enable_libstdcxx_time" != x"no"; then
 
     if test x"$enable_libstdcxx_time" = x"rt"; then
diff --git a/libstdc++-v3/config/os/bionic/ctype_base.h b/libstdc++-v3/config/os/bionic/ctype_base.h
index 2eb5dcaff79..b112a272152 100644
--- a/libstdc++-v3/config/os/bionic/ctype_base.h
+++ b/libstdc++-v3/config/os/bionic/ctype_base.h
@@ -28,6 +28,18 @@
 
 // Information as gleaned from /usr/include/ctype.h
 
+// _CTYPE prefix was added in NDK r14 unified headers
+#ifndef _CTYPE_U
+#define _CTYPE_U _U
+#define _CTYPE_L _L
+#define _CTYPE_D _N
+#define _CTYPE_S _S
+#define _CTYPE_P _P
+#define _CTYPE_C _C
+#define _CTYPE_X _X
+#define _CTYPE_B _B
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -41,17 +53,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     // NB: Offsets into ctype<char>::_M_table force a particular size
     // on the mask type. Because of this, we don't use an enum.
     typedef char 		mask;
-    static const mask upper    	= _U;
-    static const mask lower 	= _L;
-    static const mask alpha 	= _U | _L;
-    static const mask digit 	= _N;
-    static const mask xdigit 	= _X | _N;
-    static const mask space 	= _S;
-    static const mask print 	= _P | _U | _L | _N | _B;
-    static const mask graph 	= _P | _U | _L | _N;
-    static const mask cntrl 	= _C;
-    static const mask punct 	= _P;
-    static const mask alnum 	= _U | _L | _N;
+    static const mask upper    	= _CTYPE_U;
+    static const mask lower 	= _CTYPE_L;
+    static const mask alpha 	= _CTYPE_U | _CTYPE_L;
+    static const mask digit 	= _CTYPE_D;
+    static const mask xdigit 	= _CTYPE_X | _CTYPE_D;
+    static const mask space 	= _CTYPE_S;
+    static const mask print 	= _CTYPE_P | _CTYPE_U | _CTYPE_L | _CTYPE_D | _CTYPE_B;
+    static const mask graph 	= _CTYPE_P | _CTYPE_U | _CTYPE_L | _CTYPE_D;
+    static const mask cntrl 	= _CTYPE_C;
+    static const mask punct 	= _CTYPE_P;
+    static const mask alnum 	= _CTYPE_U | _CTYPE_L | _CTYPE_D;
 #if __cplusplus >= 201103L
     static const mask blank 	= space;
 #endif
diff --git a/libstdc++-v3/config/os/newlib/os_defines.h b/libstdc++-v3/config/os/newlib/os_defines.h
index be010fe4ec9..918a33ed3bf 100644
--- a/libstdc++-v3/config/os/newlib/os_defines.h
+++ b/libstdc++-v3/config/os/newlib/os_defines.h
@@ -34,7 +34,6 @@
 // file will come before all others.
 
 #ifdef __CYGWIN__
-#define _GLIBCXX_GTHREAD_USE_WEAK 0
 
 #if defined (_GLIBCXX_DLL)
 #define _GLIBCXX_PSEUDO_VISIBILITY_default __attribute__ ((__dllimport__))
@@ -58,4 +57,9 @@
 
 #endif
 
+#define _GLIBCXX_GTHREAD_USE_WEAK 0
+#define _GTHREAD_USE_MUTEX_INIT_FUNC  1
+#define _GTHREAD_USE_COND_INIT_FUNC  1
+#define _GLIBCXX_USE_SCHED_YIELD      1
+
 #endif
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 61457e940ec..22d9fe4a605 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -20828,6 +20828,13 @@ fi
         ;;
     esac
 
+  elif test x"$enable_libstdcxx_time" = x"yes"; then
+    # xtensa-esp32: This sets the same settings for canadian cross and native builds
+    ac_has_clock_monotonic=yes
+    ac_has_clock_realtime=yes
+    ac_has_nanosleep=no
+    ac_has_sched_yield=yes
+
   elif test x"$enable_libstdcxx_time" != x"no"; then
 
     if test x"$enable_libstdcxx_time" = x"rt"; then
diff --git a/libstdc++-v3/include/bits/locale_facets.h b/libstdc++-v3/include/bits/locale_facets.h
index d5384e1469e..774a107fb34 100644
--- a/libstdc++-v3/include/bits/locale_facets.h
+++ b/libstdc++-v3/include/bits/locale_facets.h
@@ -47,6 +47,20 @@
 #include <ext/numeric_traits.h>
 #include <bits/streambuf_iterator.h>
 
+#if !__clang__ && __GNUC__ == 4 && __GNUC_MINOR__ == 9 && __i386__
+// CrystaX: for some reason, x86 gcc-4.9 makes ctype<char>::do_widen() and
+// ctype<char>::_M_widen_init() methods working wrong if optimization enabled.
+// For ctype<char>::do_widen(), values of passed arguments (__lo, __hi and __to)
+// are completely messed up and don't correspond to passed values. In case if
+// we disable optimization for those methods, things become correct so we apply
+// this workaround here for a time.
+// TODO: figure out what exactly wrong here - is it bug in GCC optimization
+// algorithm or smth else?
+#define __CRYSTAX_X86_DONT_OPTIMIZE __attribute__((optimize(0)))
+#else
+#define __CRYSTAX_X86_DONT_OPTIMIZE
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -1104,7 +1118,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
        *  @return  @a __hi.
       */
       virtual const char*
-      do_widen(const char* __lo, const char* __hi, char_type* __to) const
+      do_widen(const char* __lo, const char* __hi, char_type* __to) const __CRYSTAX_X86_DONT_OPTIMIZE
       {
 	if (__builtin_expect(__hi != __lo, true))
 	  __builtin_memcpy(__to, __lo, __hi - __lo);
@@ -1167,7 +1181,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
     private:
       void _M_narrow_init() const;
-      void _M_widen_init() const;
+      void _M_widen_init() const __CRYSTAX_X86_DONT_OPTIMIZE;
     };
 
 #ifdef _GLIBCXX_USE_WCHAR_T
diff --git a/libstdc++-v3/libsupc++/eh_alloc.cc b/libstdc++-v3/libsupc++/eh_alloc.cc
index 0323eb2fb2a..8eaa6312580 100644
--- a/libstdc++-v3/libsupc++/eh_alloc.cc
+++ b/libstdc++-v3/libsupc++/eh_alloc.cc
@@ -73,6 +73,14 @@ using namespace __cxxabiv1;
 # define EMERGENCY_OBJ_COUNT	4
 #endif
 
+static const size_t DEFAULT_ARENA_SIZE = EMERGENCY_OBJ_SIZE * EMERGENCY_OBJ_COUNT * sizeof (__cxa_dependent_exception);
+
+extern "C" size_t __cxx_eh_arena_size_get() __attribute__((weak));
+extern "C" size_t __cxx_eh_arena_size_get()
+{
+    return DEFAULT_ARENA_SIZE;
+}
+
 namespace __gnu_cxx
 {
   void __freeres();
@@ -118,9 +126,11 @@ namespace
     {
       // Allocate the arena - we could add a GLIBCXX_EH_ARENA_SIZE environment
       // to make this tunable.
-      arena_size = (EMERGENCY_OBJ_SIZE * EMERGENCY_OBJ_COUNT
-		    + EMERGENCY_OBJ_COUNT * sizeof (__cxa_dependent_exception));
-      arena = (char *)malloc (arena_size);
+      arena = NULL;
+      arena_size = __cxx_eh_arena_size_get();
+      if (arena_size > 0) {
+        arena = (char *)malloc (arena_size);
+      }
       if (!arena)
 	{
 	  // If the allocation failed go without an emergency pool.
diff --git a/libstdc++-v3/libsupc++/guard.cc b/libstdc++-v3/libsupc++/guard.cc
index 3a2ec3ad0d6..ffcd22cf1ef 100644
--- a/libstdc++-v3/libsupc++/guard.cc
+++ b/libstdc++-v3/libsupc++/guard.cc
@@ -34,7 +34,12 @@
 #if defined(__GTHREADS) && defined(__GTHREAD_HAS_COND) \
   && (ATOMIC_INT_LOCK_FREE > 1) && defined(_GLIBCXX_HAVE_LINUX_FUTEX)
 # include <climits>
+#if defined(__ANDROID__)
+# include <sys/syscall.h>
+# define SYS_futex __NR_futex
+#else
 # include <syscall.h>
+#endif
 # include <unistd.h>
 # define _GLIBCXX_USE_FUTEX
 # define _GLIBCXX_FUTEX_WAIT 0
diff --git a/libtool-ldflags b/libtool-ldflags
index 5de9e2978d4..0dde24bedfc 100755
--- a/libtool-ldflags
+++ b/libtool-ldflags
@@ -36,6 +36,11 @@ prev_arg=
 for arg
 do
     case $arg in
+	-framework)
+	    # libtool handles this option. It should not be prefixed with
+	    # -Xcompiler, as that would split it from the argument that
+	    # follows.
+	    ;;
 	-f*|--*|-static-lib*|-shared-lib*|-B*)
 	    # Libtool does not ascribe any special meaning options
 	    # that begin with -f or with a double-dash.  So, it will
